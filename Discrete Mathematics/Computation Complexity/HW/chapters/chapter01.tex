\section{Домашнее задание}


\subsection{Задача \textbf{(8 баллов)}}

Рассмотрим машины Тьюринга, которые имеют одну ленту и две команды сдвига: на две ячейки направо или на три ячейки налево.

\begin{enumerate}
    \item \textbf{(3 балла)} Дайте формальное определение машин с таким свойством как кортежей определённого вида, а также определение вычисления на такой машине, если его требуется изменить.
          \begin{solution}
              Кортеж $(\Sigma, \Gamma, Q, q_1, q_a, q_r, \delta)$ из стандартного определения машины Тьюринга за исключением того, что $\delta \,: \left(Q \, \backslash \, \{q_a, q_r\} \right) \times \Gamma \rightarrow Q \times \Gamma \times \{N, RR, LLL\} $. То есть, либо сразу сдвигаемся на 2 ячейки вправо, либо на три влево, либо стоим на месте.
          \end{solution}
    \item \textbf{(2 балла)} Докажите, что стандартную одноленточную машину Тьюринга можно смоделировать на машине такого ввида с не более чем полиномиальным замедлением.
          \begin{solution}
              Пусть $M = (\Sigma, \Gamma, Q, q_1, q_a, q_r, \delta)$ - стандартная машина Тьюринга. Построим $M^* = (\Sigma, \Gamma, Q^*, q_1, q_a, q_r, \delta^*)$, где $\delta^*$ и $Q^*$ определяется следующим образом: $\forall \Delta = (q_s, \gamma_s, q_d, \gamma_d, S) \in \delta$
              \begin{itemize}
                  \item $S = N \Rightarrow \Delta^* = \Delta$
                  \item $S = R \Rightarrow \Delta_0^* = (q_s, \gamma_s, q', \gamma_d, RR)$, $\forall \gamma \in \Gamma: \, \Delta_1^* = (q', \gamma, q'', \gamma, RR)$, $\forall \gamma \in \Gamma: \, \Delta_2^* = (q'', \gamma, q_d, \gamma, LLL)$
                  \item $S = L \Rightarrow \Delta_0^* = (q_s, \gamma_s, q', \gamma_d, RR), \forall \gamma \in \Gamma: \, \Delta_1^* = (q', \gamma, q_d, \gamma, LLL)$
              \end{itemize}
              $q', q''$ задаются отдельно для каждого перехода. $Q^*$ состоит из $Q$ и всех добавленных $q', q''$. Таким образом, мы для каждого перехода в исходной машине Тьюринга добавили переход в модифицированной, смоделировав ее работу. А так как в новые состояния, не содержащиеся в $Q$, мы можем попасть только при сдвигах на $RR$ или $LLL$, то ничего дополнительно лишнего у нас не появилось тоже. Для каждого перехода мы добавили не более $\mathcal{O}(\Gamma)$ переходов, не более 3 состояний, каждый переход увеличился не более чем в три раза. Значит, итоговое замедление не превосходит $poly(\Gamma)$.
          \end{solution}
    \item \textbf{(3 балла)} Докажите, что машину такого вида можно смоделировать на классической одно- или многоленточной машине Тьюринга с не более чем полиномиальным замедлением.
          \begin{solution}
              Пусть $M = (\Sigma, \Gamma, Q, q_1, q_a, q_r, \delta)$ - машина Тьюринга такого вида. Построим $M^* = (\Sigma, \Gamma, Q^*, q_1, q_a, q_r, \delta^*)$, где $\delta^*$ и $Q^*$ определяется следующим образом: $\forall \Delta = (q_s, \gamma_s, q_d, \gamma_d, S) \in \delta$
              \begin{itemize}
                  \item $S = N \Rightarrow \Delta^* = \Delta$
                  \item $S = LLL \Rightarrow \Delta_0^* = (q_s, \gamma_s, q', \gamma_d, L)$, $\forall \gamma \in \Gamma: \, \Delta_1^* = (q', \gamma, q'', \gamma, L)$, $\forall \gamma \in \Gamma: \, \Delta_2^* = (q'', \gamma, q_d, \gamma, L)$
                  \item $S = RR \Rightarrow \Delta_0^* = (q_s, \gamma_s, q', \gamma_d, R), \forall \gamma \in \Gamma: \, \Delta_1^* = (q', \gamma, q_d, \gamma, R)$
              \end{itemize}
              $q', q''$ задаются отдельно для каждого перехода. $Q^*$ состоит из $Q$ и всех добавленных $q', q''$. Таким образом, мы для каждого перехода в машине Тьюринга такого вида добавили переход в стандартной, смоделировав ее работу. А так как в новые состояния, не содержащиеся в $Q$, мы можем попасть только при сдвигах на $R$ или $L$, то ничего дополнительно лишнего у нас не появилось тоже. Для каждого перехода мы добавили не более $\mathcal{O}(\Gamma)$ переходов, не более 3 состояний, каждый переход увеличился не более чем в три раза. Значит, итоговое замедление не превосходит $poly(\Gamma)$.
          \end{solution}
\end{enumerate}


\subsection{Задача \textbf{(8 баллов)}}

Докажите, что если $A \in$ \textbf{NP}, то и язык $A^* = \{y | \, \exists z \in A, |z| \leq |y|^2: z$ является палиндромом, $y$ является подсловом $z\}$ также лежит в \textbf{NP}.

\begin{solution}
    Пусть $V(z, s)$ - верификатор языка $A$. Построим верификатор $V^*(y, x)$ с сертификатом $x = z\#s$. Алгоритм его работы:
    \begin{itemize}
        \item  Считываем первые $\min(|z|, |y|^2 + 1)$ символов сертификата $z$. Если считали более $|y|^2$ символов и не встретили $\#$, то возвращаем $0$
        \item Возвращаемся назад на нулевую позицию. Проверяем, что $z \in A$ за $poly(|z|) \sim poly(|y|^2) \sim poly(|y|)$, моделируя $V(z, s)$.
        \item Проверяем, что $z$ - палиндром за $poly(|z|) \sim poly(|y|^2) \sim poly(|y|)$
        \item Проверяем, что $y$ яаляется подсловом $z$ за $poly(|z| + |y|) \sim poly(|y|^2) \sim poly(|y|)$
    \end{itemize}
    Построили верификатор $V(y, x)$, работающий за $poly(|y|) \Rightarrow A^* \in $ \textbf{NP}
\end{solution}


\subsection{Задача \textbf{(8 баллов)}}

Определим класс \textbf{NP*} следующим образом: $A \in $ \textbf{NP*} $\Leftrightarrow \exists V(x, s)$, вычислимый за время $poly(|x|)$, со следующим условием: $x \in A \Leftrightarrow \exists s: \, V(x, s) = 1 \, \wedge \, V(x, s^*) = 1$ для любого $s^*$, отличающегося от $s$ стиранием каких-то двух битов). Докажите, что \textbf{NP} $=$ \textbf{NP*}.

\begin{solution}
    Докажу включение в обе стороны:
    \begin{enumerate}
        \item \textbf{NP*} $\subset$ \textbf{NP}
              Пусть верификатор произвольного языка $A \in $ \textbf{NP*} - $V(x, s) = (V(x, s) = 1 \, \wedge \, V(x, s^*) = 1$ для любого $s^*$, отличающегося от $s$ стиранием каких-то двух битов) Построим верификатор $V^*(x, s)$ для  $A$, работающий за $poly(|x|)$, тем самым доказав принадлежность \textbf{NP}. Его алгоритм:
              \begin{itemize}
                  \item Моделирует $V(x, s)$ за $poly(|x|)$
                  \item Перебирает всевозможные подмножества $s^*$ битов $s$ размера $|s| - 2$, полученные путем стирания из $s$ каких-то двух битов за $poly(|s|^2) \sim poly(|x|)$ (так как мы за $poly(x)$ уже проверили, что $V(x, s) = 1)$, то количество вариантов в переборе - $poly(|x|)$, записывает на ленту и моделирует $V(x, s^*)$ за $poly(|x|)$. Итого - $poly(|x|)$.
              \end{itemize}
        \item \textbf{NP} $\subset$ \textbf{NP*}
              Пусть верификатор языка $A \in$ \textbf{NP} - $V(x, s)$. Построим верификатор $V^*(x, s)$ для $A$ вида \textbf{NP*}. Пусть $V^*(x, sss) = 1 \Leftrightarrow V(x, s) = 1$, $V^*(x, s) = 1: \Leftrightarrow |x| \equiv_3 1$, $V^*(x, s) = 0: \Leftrightarrow |x| \equiv_3 2$. Тогда если $x \in A$, то $\exists s: \, V(x, s) = 1 \Leftrightarrow V^*(x, sss) = 1 \wedge \, V^*(x, s^*) = 1$ для любого $s^*$, отличающегося от $s$ стиранием каких-то двух битов, так как $|s^*| \equiv_3 1$. Если $\exists s: \, V^*(x, s) = 1$, то либо $|s| \equiv_3 0$ и тогда $s=ttt$ и $V(x, t) = 1 \Leftrightarrow x \in A$ по построению, либо $|s| \equiv_3 1$, но тогда $V^*(x, s^*) = 0$ для любого $s^*$, отличающегося от $s$ стиранием каких-то двух битов, так как $|s^*| \equiv_3 2$. Значит, взяв верификатором $V^*(x, s)$, мы получим, что он примет те же слова $x$, что и $V(x, s)$, то есть язык, полученный по $V^*(x, s)$, совпадает с $A$.
    \end{enumerate}
    Получаем, что \textbf{NP} $=$ \textbf{NP*}
\end{solution}


\subsection{Задача \textbf{(8 баллов)}}

Определим язык \textbf{SHORTPATHS} $= \{(G, s, t, k) |$ в ориентированном графе $G$ любой простой путь из $s$ в $t$ имеет длину не больше $k\}$. Лежит ли этот язык в \textbf{P}, \textbf{NP}, \textbf{coNP}? Докажите утверждения, которые можете доказать, а догадки - сформулируйте и поясните интуицию.

\begin{solution}
    \textbf{SHORTPATHS} принадлежит \textbf{coNP}, так как для проверки наличия хотя бы одного простого пути длины более, чем $k$ можно построить верификатор $V(G, path)$, который по данному ему сертификату пути $path$ проверял бы, что это - путь из $s$ в $t$ и что его длина больше, чем $k$ за полиномиальное время от размера графа.

    Предположим что \textbf{SHORTPATHS} лежит в \textbf{P}. Рассмотрим задачу существования гамильтонова пути, которая в свою очередь принадлежит \textbf{NP}.
    Запустим \textbf{SHORTPATHS}$(G, 0, 1, n - 2)$, где $n$ - количество вершин в графе $G$. Если мы получаем $accept$, то это автоматически значит, что гамильтонова пути не существует, так как все простые пути недостаточно длинные.
    Если получим \textbf{REJECT}, то это значит что есть путь длины $n - 1$, следовательно в силу его простоты он --- гамильтонов.

    Предположим, что \textbf{SHORTPATHS} лежит в \textbf{NP}. В классе \textbf{NP} проверка принадлежности объекта языку сводится к проверке корректности "свидетельства" за полиномиальное время.
    Например, в \textbf{NP} для проверки, что существует путь длиной $\leq k$, можно предъявить такой путь.
    Однако \textbf{SHORTPATHS} требует, чтобы все простые пути из $s$ в $t$ были длиной $\leq k$.
    Проверка всех простых путей за полиномиальное время невозможна (их количество экспоненциально растёт от размера графа).
    Значит, скорее всего \textbf{SHORTPATHS} $\notin$ \textbf{NP}.
\end{solution}


\subsection{Задача \textbf{(8 баллов)}}

Докажите \textbf{NP}-полноту языка \textbf{ONE-THIRD-3SAT} $ = \{\phi | \phi $ есть формула в формате 3-КНФ (рассмотрите 2 случая: когда в каждой скобке ровно 3 литерала и когда не более трёх), у которой есть выполняющий набор, в котором ровно треть переменных равна $1 \}$

\begin{solution}
    Сведем \textbf{3SAT} к \textbf{ONE-THIRD-3SAT}. Пусть есть формула $\phi$ вида \textbf{3SAT} с $n$ переменными. Построим $\phi^*$, добавив еще $2n$ переменных  $y_1, y_2, \dots, y_{2n}$ и дизъюнкты, которые обеспечат, что ровно треть из имеющихся переменных будет равна 1: $\forall i: \, (x_1 \vee y_{2i - 1} \vee y_{2_i}) \wedge (\neg x_1 \vee \neg y_{2i - 1} \vee y_{2_i}) \wedge (\neg x_1 \vee y_{2i - 1} \vee \neg y_{2_i}) \wedge (x_1 \vee \neg y_{2i - 1} \vee \neg y_{2_i}) \wedge (\neg x_1 \vee \neg y_{2i - 1} \vee \neg y_{2_i})$. Таким образом, если у исходной формулы $\phi$ был выполняющий набор, то у нашей новой построенной формулы он так же будет с соответствующими значениями $y_i$, при которых они дополняют до трети от общего количества переменных уже истинные из $x_i$. Если же у нашей построенной формулы есть выполняющий набор, то, отбросив $y_i$, мы получим выполняющий набор для $\phi$.
\end{solution}


\subsection{Задача \textbf{(10 баллов)}}

Докажите \textbf{NP}-полноту языка \textbf{SCSS} $= \{(R, k) \, | \, R \subset \Sigma^*, \exists w \in \Sigma^k: \, \forall x \in R: \, x \sqsubset w\}$. (Задача о наименьшей надстроке в алфавите $\Sigma$).

\begin{solution}
    Докажу принадлежность к классу \textbf{NP} и \textbf{NP}-трудность.
    \begin{itemize}
        \item \textbf{SCSS} $\in$ \textbf{NP}. Построим верификатом, работающий за полиномиальное время. Сертификат - строка $w$. Алгоритм работы верификатоа:
              \begin{enumerate}
                  \item Считываем первые $\min(|w|, k + 1)$ символ. Если считали более $k$, то возвращаем 0. Иначе слвигаемся в начало
                  \item Для каждого слова $x \in R$ проверяем за полиномиальное время, содержится ли она в $w$ как подстрока. Суммарно это можно сделать за $\mathcal{O}(k|R|)$. Если все содержатся, то 1, иначе - 0.
              \end{enumerate}
              Таким образом мы предъявили верификатор, значит \textbf{SCSS} $\in$ \textbf{NP}
        \item Покажем \textbf{NP}-полноту. Сведем задачу \textbf{HAMCYCLE} к нашей. Пусть есть граф $G = (V, E)$. $\Sigma = \{v_1, \dots, v_n\}$. $R$ будет множеством, в котором содержится $v_iv_j$ тогда и только тогда, когда такое ребро есть в графе. При этом больше ничего содержать не будет. Пусть $k = n+1$. Тогда если в графе существует гамильтонов цикл, то существует и строка $w$ длины, состоящая из последовательности обхода вершин в этом цикле с возвращением стартовую, которая будет содержать все слова из $R$ как подстроки.
    \end{itemize}
\end{solution}


\subsection{Задача \textbf{(8 баллов)}}

В явном виде опишите самосводимость в задаче поиска, соответствующей языку \textbf{CLAQUE} $= \{(G, k) \, |$ в графе $G$ есть полный двудольный подграф с долями размера по $k\}$. (Иными словами, найдутся $V_1$ и $V_2$, такие что $|V_1| = |V_2| = k$ и $V_1 \times V_2 \subset E)$.

\begin{solution}
    Представлю алгоритм для задачи поиска в $G = (V, E)$ полной двудольной клики $K_{k, k}$ размера $k$:
    \begin{enumerate}
        \item Проверим принадлежание $(G, k)$ языку \textbf{CLAQUE} при помощи обращения к оракулу языка 1 шаг. Если получили \textbf{REJECT}, то возвращаем остутствие.
        \item Последовательно будем удалять непомеченные вершины с инцидентными ей ребрами и повторять шаг $1$ до тех пор, пока получаем \textbf{ACCEPT} за не более чем $|V|$ шагов.
        \item Как только на каком-то шаге получили \textbf{REJECT}, возвращаем эту вершину вместе с инцидентными ей ребрами, помечаем ее и записываем ее в $V_1$.
        \item Повторяем шаги $2$, $3$ до тех пор, пока все вершины не станут помеченными.
    \end{enumerate}
    В итоге в графе останутся только вершины, принадлежашие $K_{k, k}$. Запустим \textbf{DFS}, относя вершины к $V_1$ и $V_2$ поочередно: если предок отнесен к $V_1$, то текущая должна быть отнесена к $V_2$ и наоборот.
    В итоге получим требуемое разбиение $K_{k, k}$ на две доли $V_1$ и $V_2$.

    Оценим количество операций. Вершина может быть удалена не более одного раза --- после этого она либо становится помеченнй, либо навсегда пропадет из графа.
    Количество обращений к оракулу языка \textbf{CLAQUE} равно сумме количаства удаленных, количества помеченных, увеличенном на 1.
    Итого мы сделаем $\mathcal{O}(|V|)$ обращений к оракулу и $\mathcal{O}(|V|)$ дополнительных операций с учетом \textbf{DFS}.
\end{solution}


\subsection{Задача \textbf{(10 баллов)}}

Докажите, что \textbf{P} $\neq$ \textbf{NTIME}$(n^2)$. (Если потребуется какая-либо теорема об иерархии, можно ей пользоваться без доказательства).

\begin{solution}
    Предположим, что \textbf{P} $=$ \textbf{NTIME}$(n^2)$.
    Пусть $f(n) = n^2$, $g(n) = n^4$. Тогда $f(n+1) = (n+1)^2 = o(n^4)$, и по теореме об иерархии $NTIME(n^2) \subsetneq NTIME(n^4)$.

    Предположим \textbf{P} $=$ \textbf{NTIME}$(n^2)$. Пусть $A \in$ \textbf{NTIME}$(n^4) \, \setminus$ \textbf{NTIME}$(n^2)$.
    Пусть $V(x, s)$ — функция, вычисляющая $A$. Пусть $V_1(t, s)$ — вычислимая функция, которая делает следующее:
    \begin{enumerate}
        \item Проверяет, что $t = x1^{|x|^2 - |x|} = x1^{n^2 - n}$. Для этого:
              \begin{itemize}
                  \item считает длину входа $|t|$,
                  \item проверяет, что $|t| = n^2$ (полный квадрат),
                  \item вычисляет корень $|t|$,
                  \item проверяет, что начиная с $n+1$-го символа, символы равны $1$.
              \end{itemize}

        \item Извлекает $x$ из $t$. Для этого читает первые $n$ символов $t$.

        \item Если все проверки завершились успешно, то вычисляет и возвращает $V(x, s)$, иначе возвращает $0$.
    \end{enumerate}

    Первые два пункта алгоритма можно проделать за $O(n^3)$, а именно перебирая числа от $1$ до $n$ и проверяя,
    равен ли квадрат числа $n^2$. Всего проверок $n$, а посчитать $x^2$ можно за $O(x^2) = O(n^2)$
    (итерации закончатся, как только $x^2 > |t|$). Таким образом, алгоритм сработает за $O(\sqrt{|t|}|t|) = O(|t|^2)$.

    Третий пункт сработает за $O(n^4) = O(|t|^2)$. Итого, алгоритм сработает за $O(|t|^2)$.

    Получили $S = \{x \mid \exists x_1 \in A \ (x = x_1 1^{|x_1|^2 - |x_1|})\} \in DTIME(n^2) \in P$.
    Так как $P$ замкнут относительно сводимостей, а $A$ полиномиально сводится к $S$
    ($x \in A \Leftrightarrow x1^{|x|^2 - |x|} \in S$), то $A \in P = NTIME(n^2)$, что противоречит выбору $A$.

\end{solution}
