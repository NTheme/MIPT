\section{Домашнее задание}

\subsection{\textbf{Задача (5 баллов)}}

Приведя явную формулу, классифицируйте как можно точнее в полиномиальной иерархии язык
\textbf{INDSETUNIONSIZE} $= \{(G, k, l) \mid$ объединение всех независимых множеств графа $G$ размера $k$ имеет мощность $l\}$.
Возможные ответы: $\Sigma_k^p$, $\Pi_k^p$, $\Sigma_k^p \cap \Pi_k^p$ для указанных вами $k$.

\begin{solution}
    Пусть $G = (V, E)$. Тогда условие можно переписать в следующем виде:
    $$\exists A \forall B \, (A \subseteq V \wedge |A| = l \wedge (B \nsubseteq V \vee B \text{ --- не независимое множество } \vee B \subseteq A))$$

    Все проверки осуществляются за полиномиальное время, следовательно \textbf{INDSETUNIONSIZE} $\in \Sigma_2^p$.

\end{solution}


\subsection{Задача \textbf{(5 баллов)}}

Классифицируйте язык \textbf{HAMPATHEXT} $= \{(G, k, s, t) \mid$ ориентированный граф $G$ задан списком рёбер
$e_1, \ldots, e_m$, причём при любом выборе по одному элементу из каждой пары $(e_1, e_2), (e_3, e_4), \ldots, (e_{2k-1}, e_{2k})$
в $G$ найдётся гамильтонов путь из $s$ в $t$, использующий выбранные рёбра$\}$ в один из классов
$\Sigma_2^p$ и $\Pi_2^p$ и докажите его полноту в этом классе.

\begin{solution}
    Пусть $G (V, E)$. Тогда условие можно переписать в следующем виде:
    $$\forall A \exists B \, (A \notin \{0, 1\}^k \vee B|_A \text{ --- гамильтонов путь с индексами } A)$$
    То есть, $B$ --- гамильтонов путь, множество ребер которого содержит множество ребер из условия
    с выбером из кажюой пары первого, если в $A$ на соответствующем месте стоит 0 и второго если наоборот.

    Это условие проверяется за полиномиальное время (просто пройтись по $B$).
    Значит, \textbf{HAMPATHEXT} $\in \Pi_2^p$.

    Докажем $Pi_2^p$-трудность. Сведем $\mathbf{\Pi_2^p-3SAT}$ к \textbf{HAMPATHEXT}.
    Построим конструкцию такую же, как и при сводимости \textbf{3SAT} к \textbf{HAMPATH}.

    $\forall y_1 \exists y_2 \phi(y_1, y_2) = 1 \Leftrightarrow \phi \in \mathbf{\Pi_2^p-3SAT} \Leftrightarrow f(\phi) \in \mathbf{HAMPATHEXT}$.

    Обозначим за $e_1, ... e_{2k}$ верхние пары ребер тех гаджетов, которые соответствуют переменным из $y_1$.
    Тогда выбор тех переменных из $y_1$, которым присваивается 1, равносилен выбору множества $A$ (из каждого берем либо одно, либо другое) в зависимости от направления прохода,
    а выбор значений $y_2$ равносилен поиску гамильтонова пути в графе: если при заданном $\phi$ в графе с любыми наложенными $y_1$ ограничениями путь найдется, то из
    этого следует, что $\phi \in \mathbf{\Pi_2^p-3SAT}$ и наоборот, что и требовалось.
\end{solution}


\subsection{Задача \textbf{(5 баллов)}}

Докажите PSPACE-полноту языка \textbf{FUNCBASE} $= \{(A, F, h) \mid F$ есть набор функций из конечного множества $A$ в себя,
композицией которых выражается функция $h\}$.

\begin{solution}
    Покажу принадлежность. Будем каждую функцию из множества $F$ представлять в виде таблицы значений (так как функции отображают элементы конечного множества $A$ в себя).

    Приведу явный алгоритм для доказательства принадлежания \textbf{PSPACE}:
    \begin{itemize}
        \item Для каждого элемента $x \in A$ необходимо вычислить результат композиции функций из $F$, начиная с применения функции $f_1$, затем $f_2$ и так далее, вплоть до $f_k$.
        \item На каждом шаге алгоритм сохраняет промежуточный результат и использует его для следующей итерации.
        \item Алгоритм завершится, когда будет проверено, можно ли выразить функцию $h$ как композицию функций из множества $F$.
    \end{itemize}

    Поскольку количество промежуточных результатов ограничено полиномиально от размера множества $A$, а количество функций в $F$ также ограничено полиномиально от числа переменных,
    процесс вычисления композиции выполнится с использованием полиномиального пространства.
    Следовательно, \textbf{FUNCBASE} $\in \mathbf{PSPACE}$.

    Теперь докажем \textbf{PSPACE}-полноту \textbf{FUNCBASE}. Рассмотрим \textbf{TQBF}, которая является \textbf{PSPACE}-полной.
    Представим каждую переменную $x_i$ как элемент конечного множества $A = \{0, 1\}$, так как переменная может принимать два возможных значения.

    \begin{enumerate}
        \item Каждому квантору $Q_i$ можно сопоставить функцию из множества $F$:
              \begin{itemize}
                  \item Для квантора $\forall x_i$ (универсальный квантор) создадим функцию, которая для всех значений $x_i \in A$ проверяет выполнение формулы $\varphi(x_1, x_2, \dots, x_n)$ для этих значений.
                  \item Для квантора $\exists x_i$ (существующий квантор) создадим функцию, которая для некоторого значения $x_i \in A$ проверяет выполнение формулы $\varphi(x_1, x_2, \dots, x_n)$, если $x_i$ примет это значение.
              \end{itemize}

        \item Функция $h$, которую нужно выразить через композицию функций из набора $F$, будет представлять собой функцию, которая возвращает 1, если формула \textbf{TQBF} истинна, и 0, если ложна.

        \item Алгоритм сводится к проверке, можно ли выразить функцию $h$ как композицию функций из множества $F$, соответствующих кванторам и переменным формулы \textbf{TQBF}.
    \end{enumerate}

    Редукция из \textbf{TQBF} в \textbf{FUNCBASE} выполняется за полиномиальное время и пространство, так как:
    \begin{itemize}
        \item Каждую переменную можно представить как элемент множества $A = \{0, 1\}$, что даёт два возможных значения для каждой переменной.
        \item Для каждого квантора мы строим соответствующую функцию, и их количество ограничено числом переменных и кванторов в формуле, что даёт полиномиальное количество функций.
        \item Проверка, можно ли выразить функцию $h$ как композицию функций, также выполняется за полиномиальное количество шагов, так как число шагов ограничено числом переменных и кванторов.
    \end{itemize}

    Таким образом, редукция из \textbf{TQBF} в \textbf{FUNCBASE} является полиномиальной по пространству $\Rightarrow$ \textbf{FUNCBASE} \textbf{PSPACE}-полна.
\end{solution}


\subsection{Задача \textbf{(5 баллов)}}

Докажите, что язык \textbf{CYCLECOMPONENT} $= \{G \mid$ хотя бы одна связная компонента неориентированного графа $G$
является циклом$\}$ лежит в \textbf{L}. Граф задан матрицей смежности или списком рёбер, на ваш выбор.
В частности, нужно проверить, что он неориентированный.

\begin{solution}
    Приведу алгоритм.
    \begin{enumerate}
        \item  \textbf{Проверка неориентированности графа, заданного матрицей смежности:}

              \begin{enumerate}
                  \item Перебираем все пары индексов $i, j$ с $i < j$.
                  \item Если существует пара $i, j$, для которой $a_{ij} \neq a_{ji}$, то граф ориентированный, и возвращаем \textbf{REJECT}.
              \end{enumerate}
              Для хранения текущих индексов $i, j$ требуется $O(\log n)$ памяти.

        \item \textbf{Нахождение связных компонентов графа}

              Для разбиения графа на связные компоненты используем (BFS).
              Память:
              \begin{itemize}
                  \item Для BFS достаточно $O(\log n)$ дополнительной памяти для хранения текущей вершины и её соседей.
                  \item Помеченные вершины моделируются через последовательные обходы без явного хранения структуры $visited$.
              \end{itemize}

        \item \textbf{3. Проверка, является ли компонента циклом}
              \begin{enumerate}
                  \item Подсчитываем число вершин ($n$) и число рёбер ($m$) в компоненте:
                        \begin{itemize}
                            \item $n$ — количество вершин, посещённых в обходе.
                            \item $m$ — количество рёбер, исходящих из посещённых вершин.
                        \end{itemize}
                  \item Проверяем, что:
                        \begin{itemize}
                            \item $m = n$ (в компоненте ровно $n$ рёбер),
                            \item степень каждой вершины равна 2 (каждая вершина инцидентна ровно двум рёбрам).
                        \end{itemize}
              \end{enumerate}

              Память:
              \begin{itemize}
                  \item Для подсчёта $n$ и $m$ достаточно $O(\log n)$ памяти.
                  \item Проверка степени каждой вершины выполняется во время обхода, что требует $O(\log n)$ памяти.
              \end{itemize}
    \end{enumerate}

    Алгоритм проверяет каждую компоненту графа и проверяет свойства цикличности (граф связен, $m = n$, степень всех вершин равна 2).
    Все наши действия требовали $O(\log(n))$ памяти, значит \textbf{CYCLECOMPONENT} $\in$ \textbf{L}.
\end{solution}


\subsection{Задача \textbf{(5 баллов)}}

Докажите, что язык \textbf{ALMOSTBIPARTITE} $= \{G \mid G$ --- граф, который становится двудольным после удаления одной вершины$\}$
\begin{enumerate}[label=\alph*.]
    \item лежит в \textbf{NL}
    \item является \textbf{NL}-полным.
\end{enumerate}

\begin{solution} ~
    \begin{enumerate}[label=\alph*.]
        \item \textbf{Принадлежность}.
              Граф $G = (V, E)$ становится двудольным после удаления вершины $v$, если оставшийся граф
              $G' = G \setminus \{v\}$ является двудольным. Приведу алгоритм:
              \begin{enumerate}
                  \item Перебираем каждую вершину $v \in V$ графа $G$ по очереди.
                  \item Проверяем, является ли $G \setminus \{v\}$ двудольным:
                        \begin{itemize}
                            \item Выполняем алгоритм \textbf{BFS} на $G \setminus \{v\}$, пытаясь раскрасить граф в два цвета.
                            \item Если встречается конфликт в раскраске (две соседние вершины одного цвета), граф
                                  $G \setminus \{v\}$ не является двудольным.
                        \end{itemize}
                  \item Если хотя бы для одной вершины $v$ граф $G \setminus \{v\}$ двудолен, возвращаем \textbf{ACCEPT}.
                        В противном случае возвращаем \textbf{REJECT}.
              \end{enumerate}

              Тогда:
              \begin{itemize}
                  \item Для хранения текущей удаляемой вершины $v$ требуется $O(\log n)$ памяти.
                  \item \textbf{BFS} требует $O(\log n)$ памяти, так как нужно хранить только текущую вершину и её соседей.
              \end{itemize}

              Так как \textbf{NL} содержит только алгоритмы, которые работают за $O(\log n)$ памяти, то алгоритм принадлежит \textbf{NL}.
              Следовательно, \textbf{ALMOSTBIPARTITE} $\in$ \textbf{NL}.

        \item \textbf{Полнота}.

              Для доказательства сведу язык \textbf{PATH}, являющийся \textbf{NL}-полным, к нашему.
              Построим сведение $(G, s, t) \mapsto G'$, такое что:
              
              $(G, s, t) \in$ \textbf{PATH} $\iff G' \in$ \textbf{ALMOSTBIPARTITE}.

              Для графа $G = (V, E)$:
              \begin{enumerate}
                  \item Добавляем новую вершину $v$.
                  \item Добавляем рёбра:
                        \begin{itemize}
                            \item $(v, s)$,
                            \item $(v, t)$,
                            \item $(v, u)$ для всех $u \in V \setminus \{s, t\}$.
                        \end{itemize}
              \end{enumerate}

              \textbf{Корректность:}

              \begin{itemize}
                  \item Если $(G, s, t) \in$ \textbf{PATH}, то существует путь из $s$ в $t$ в $G$. После удаления вершины $v$, граф $G' \setminus \{v\}$ становится двудольным, так как в $G$ нет других конфликтов.
                  \item Если $(G, s, t) \notin$ \textbf{PATH}, то путь из $s$ в $t$ отсутствует. Удаление вершины $v$ оставляет конфликт в графе $G' \setminus \{v\}$, делая его недвудольным.
              \end{itemize}

              Построение графа $G'$ занимает полиномиальное время и так же использует не более, чем разрешенную логарифмическую память,
              так как добавляется одна вершина и $O(n)$ рёбер. Следовательно, сведение выполняется за $O(n^2)$. 
              Значит, мы построили полиномиальное сведение

    \end{enumerate}
\end{solution}


\subsection{Задача \textbf{(5 баллов)}}

Докажите, что функция $BB_{\text{dec}}(n)$, возвращающая максимальную длину слова, в котором биты не возрастают
(т. е. сначала идут единицы, потом нули), являющегося в точности ответом какой-то машины Тьюринга с $n$ состояниями и
алфавитом $\{0, 1, \#\}$ на каком-то входе длины ровно $n$, растёт быстрее любой вычислимой функции.

\begin{solution}

    Предположим обратное, $\exists \text{ вычислимая функция } f \forall N \exists n > N: f(n) > BB_{\text{dec}}$.
    Пусть $M_0$ вычисляе $f$ и у нее $q_0$ состяний.
    Пусть Машина Тьюринга $M$ выполняющая следующие действия последовательно:
    \begin{itemize}
        \item Печатает двоичную запись $n$. Требует $q_1(n) = O(\log(n))$ состояний, так как двоичная запись $n$
              имеет длину $O(\log(n))$.
        \item Запускает $M_0$.
        \item Печатает $1^{f(n)+1}$, начиная с самого левого уже непустого символа на ленте и заполняет все что справа непусто нулями.
              Требует $q_2 = O(\log(f(n))) = O(\log(n))$ состояний, так как ее можно реализовать
              при помощи одного счетчика и $M$ записала на ленту ответ, используя не более $O(\log(n))$ состояний, а позиции самого левого
              и самого правого непустого запомниать параллельно с выполнением первых двух шагов.
    \end{itemize}
    Тогда $M$ будет использовать $Q = q_0 + q_1 + q_2 = O(\log(n))$ состояний и печатать невозрастающую последовательность из
    $> f(n)$ единиц и какое-то количество нулей правее - невозрастающую последовательность. Это приводит к противоречию, так как $\exists N_0 \forall n > N_0: \, n > Q$. Возьмем $N' = \max(N, N_0)$.
    Тогда $\forall n > N_1: \, f(n) + 1 \leq BB_{\text{dec}}(n) < f(n)$. Противоречие. Таким образом, $BB_{\text{dec}}(n)$
    растет быстрее любой вычислимой функции.
\end{solution}

\subsection{Задача \textbf{(10 баллов)}}

Рассмотрим случайный оракул $A$, построенный следующим образом: слов нечётной длины в нём нет,
а для каждой длины независимо от других есть ровно одно слово, являющееся квадратом (т. е. конкатенацией некоторого слова
с самим собой), распределённое равновероятно среди квадратов. Докажите, что $P^A \neq NP^A \text{ с вероятностью } 1$.

\begin{solution}

    Рассмотрим язык $A' = \{1^n \mid A \cap \{0, 1\}^n \cdot 2$ содержит слово, оканчиваюшееся на $1 \}$.

    $\{0, 1\}^n \cdot 2$ --- все слова из $\{0, 1\}^n$, конкатенированные с собой же.
    Тогда $A' \in \mathbf{NP}^a$, так как недетерминировананя машина может недетерминированно перебрать все слова
    из $\{0, 1\}^n$, конкатенированные с собой же, найти, где $A$ даст \textbf{ACCEPT} b посмотреть на последний
    бит этого слова.

    $A' \notin \mathbf{P}^A$, так как мы не можем перебрать все слова из $\{0, 1\}^n$ и спросить про их конкатенации у $A$.

    Так как запросов мы можем сделать $poly(n)$, а различных вариантов слов
    у нас $2^n$, то с вероятностью $1$ мы не сможем точно ответить про данное $n$. Отсюда получаем, что
    $A' \notin \mathbf{P}^A$. А в силу выбора языка, разделяющего по последнему биту квадрата, для которого
    вероятность, что этот бит равен $1$ равна $0.5$, как и то, что он равен $0$, в силу равновероятного распределения
    среди всех квадратов длины $2n$, мы получаем $\mathbf{P}^A \neq \mathbf{NP}^A$ с вероятностью $1$.

\end{solution}
